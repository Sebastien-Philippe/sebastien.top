# 🧭 基础算法入门

基础算法是所有信息学竞赛（OI）学习的基石。掌握好这些基础，能帮助你理解题意、锻炼编程思维，并为后续学习高级算法打下坚实的基础。

对于初学者来说，应当侧重于理解这些算法的**核心思想**和**时间复杂度**。

## 🔍 一、 模拟 (Simulation)

**模拟**通常不是一个严格意义上的算法，而是一种解决问题的**思路**。它的核心就是严格按照题目的描述和要求，将过程用程序语言**原样实现**出来。

### 应用场景

* 处理复杂的、规则明确的**流程**问题（如：日历计算、游戏回合制、大数运算）。
* 初赛和入门题中大量存在，考验选手的**细心程度**和**代码实现能力**。

**关键点：** 必须处理好边界条件和各种特殊情况。

## 🔢 二、 排序算法 (Sorting)

排序是计算机科学中最基础的操作之一，目的是将一组数据按照某种顺序（升序或降序）排列。你必须熟练掌握各种排序算法的原理、实现和性能差异。

### 重要排序算法

* **冒泡排序 (Bubble Sort)**: 简单但效率低（$O(N^2)$），主要用于教学。
* **选择排序 (Selection Sort)**: 每次选出最小/最大的元素，放到正确位置（$O(N^2)$）。
* **插入排序 (Insertion Sort)**: 适用于数据量小或基本有序的情况（$O(N^2)$）。
* **归并排序 (Merge Sort)**: 基于分治思想，稳定，最坏时间复杂度 $O(N \log N)$。
* **快速排序 (Quick Sort)**: 平均时间复杂度 $O(N \log N)$，OI中最常用的排序算法。
* **堆排序 (Heap Sort)**: 基于堆结构实现，时间复杂度 $O(N \log N)$。

在实际编程中，竞赛选手通常直接使用 STL（如 C++ 的 `std::sort`），但理解底层原理至关重要。

## ⚖️ 三、 贪心算法 (Greedy)

**贪心算法**在每一步做出当前看起来是**最优**的选择。它是一种启发式方法，希望通过一系列局部最优的选择，最终能得到全局最优解。

### 核心要素

1.  **贪心选择性质**: 局部最优选择能导致全局最优解。
2.  **最优子结构**: 问题的最优解包含子问题的最优解。

**挑战：** 贪心算法不一定总是正确的。解决贪心问题最重要的是**证明**你的贪心策略是有效的。

**经典案例：** 活动选择问题、霍夫曼编码、部分背包问题。

## 🎯 四、 二分查找 (Binary Search)

二分查找是一种在**有序数组**中查找特定元素的非常高效的算法。它每次将查找范围缩小一半，因此时间复杂度非常低，为 $O(\log N)$。


### 应用进阶：二分答案

二分查找不仅可以用于查找元素，更可以应用于求解具有**单调性**的问题，这种用法被称为**二分答案**。

如果一个问题的解 $X$ 具有这样的性质：对于所有 $\le X$ 的解都满足某个条件，对于所有 $> X$ 的解都不满足该条件，那么我们就可以在解的范围内进行二分，快速找到最优解 $X$。

### 代码实现关键点

正确处理 **`left`** 和 **`right`** 边界，以及确定 **`mid`** 更新规则，是避免死循环的关键。
